<!--Static table from csv file-->
<table id="datatable" class="display">
	<thead>
		<tr>
			{% for pair in site.data.database[0] %}
				<th>{{ pair[0] }}</th>
			{% endfor %}
		</tr>
	</thead>
	<tbody>
	{% for row in site.data.database %}
		<tr>
			{% for pair in row %}
				<td>{{ pair[1] }}</td>
			{% endfor %}
		</tr>
	{% endfor %}
	</tbody>
</table>

<br>
<div id="inspireApiContent"></div>

<!--Dynamic table using js-->
<style>
.bib-highlight {
	background-color: #ffffe0;
	border: 2px solid #ffcc00;
	padding: 10px;
	transition: background-color 0.5s ease-out, border-color 0.5s ease-out;
}
</style>
<script>
$(document).ready(function() {

	//Columns with LaTeX number rendering
	var numberColumnIndexes = [3, 4, 5];

	//Columns with inspire ids
	var inspireColumnIndexes = [6];

	//Columns with filter button (textual filters)
	var filterColumnIndexes = [0, 1, 2];

	//Number of rows entries per page
	var rowsPerPage = 30;

	// --- NEW: Unit Definitions and Conversion Factors ---
    // IMPORTANT: Assume 'factor: 1' corresponds to the unit your data comes in from site.data.database
    // All other factors convert FROM this base unit TO the target unit.
	var unitConversions = {
		// Example: Column 3 might be 'Length' (assuming original data from CSV is in meters)
		3: { // Column index 3
			default: 'm', // Default unit for display (should ideally be the base unit of your data)
			units: {
				'm': { display: 'm', factor: 1 },         // 1 meter * 1 = 1 meter
				'cm': { display: 'cm', factor: 100 },     // 1 meter * 100 = 100 cm
				'mm': { display: 'mm', factor: 1000 },    // 1 meter * 1000 = 1000 mm
				'km': { display: 'km', factor: 0.001 },   // 1 meter * 0.001 = 0.001 km
				'in': { display: 'in', factor: 39.3701 }  // 1 meter * 39.3701 = 39.3701 inches
			}
		},
		// Example: Column 4 might be 'Mass' (assuming original data from CSV is in kilograms)
		4: { // Column index 4
			default: 'kg',
			units: {
				'kg': { display: 'kg', factor: 1 },
				'g': { display: 'g', factor: 1000 },
				'lb': { display: 'lb', factor: 2.20462 } // 1 kg = 2.20462 pounds
			}
		},
		// Example: Column 5 might be 'Time' (assuming original data from CSV is in seconds)
		5: { // Column index 5
			default: 's',
			units: {
				's': { display: 's', factor: 1 },
				'ms': { display: 'ms', factor: 1000 },
				'min': { display: 'min', factor: 1/60 },
				'hr': { display: 'hr', factor: 1/3600 }
			}
		}
		// Add more numeric column definitions as needed.
		// IMPORTANT: Ensure your original data's unit aligns with the 'factor: 1' unit for each column.
	};

	// --- Function to get the current unit for a column ---
	function getCurrentUnit(colIdx) {
		// Try to get the selected value from the dropdown.
		// If the dropdown doesn't exist or has no value (e.g., during initial load before dropdown is ready),
		// fall back to the default unit defined in unitConversions.
		var currentUnit = $(`#unit-select-${colIdx}`).val();
		return currentUnit || (unitConversions[colIdx] ? unitConversions[colIdx].default : '');
	}

	// Display numbers as LaTeX
	function displayLatexNumber(num, precision = 2, unit = '') {
		if (isNaN(num) || num === null || num === undefined) {
			return ''; // Or whatever placeholder you prefer for non-numeric/null data
		}

		// Use a more readable format for numbers near 0 or small integers
		if (num === 0) {
			return `$0 ${unit}$`;
		}

        // Adjust precision for very small numbers to avoid excessive zeros
        let actualPrecision = precision;
        if (Math.abs(num) > 0 && Math.abs(num) < 0.001) { // Numbers smaller than 0.001
            // Use scientific notation, `precision` will apply to mantissa
        } else if (Math.abs(num) >= 0.001 && Math.abs(num) < 10000) {
            // Display as fixed decimal for numbers between 0.001 and 10000
            // Find appropriate precision to avoid trailing zeros but show enough detail
            if (num % 1 === 0) { // If it's an integer
                actualPrecision = 0;
            } else {
                actualPrecision = Math.max(precision, Math.min(6, num.toString().split('.')[1] ? num.toString().split('.')[1].length : 0));
                // Cap at 6 decimal places for display, or original precision, or actual decimal length
            }
            return `$${num.toFixed(actualPrecision).replace(/\.0+$/, '')} ${unit}$`; // Remove trailing .00
        }


		// Fallback to scientific notation for very large or very small numbers
		const expStr = num.toExponential(precision);
		const parts = expStr.split('e');
		let mantissa = parts[0];
		let exponent = parseInt(parts[1], 10);

		return `$${mantissa} \\times 10^{${exponent}} ${unit}$`;
	}

	//Dynamic table rendering
	var table = $('#datatable').DataTable({

		"lengthChange": false,
		"pageLength": rowsPerPage,
		"searching": true,

		layout: {
			topStart: 'search',
			topEnd: {
				buttons: [
					{
						extend: 'csv',
						exportOptions: {
							 orthogonal: 'export' // Exports the original numeric data (from render type 'export')
						},
						fieldBoundary: '', // Often better to use '"' for fieldBoundary
						fieldSeparator: ', '
					},
					{
						extend: 'excel',
						exportOptions: {
							 orthogonal: 'export' // Exports the original numeric data
						}
					},
					{
						extend: 'pdf',
						exportOptions: {
							 orthogonal: 'export' // Exports the original numeric data
						},
                        // You might need to configure pdf make further for complex LaTeX,
                        // or ensure the 'export' type returns plain text for PDF.
                        // Currently, orthogonal 'export' returns plain text for numbers, which is good.
					},
					{
						text: 'Generate bibliography',
						action: function ( e, dt, button, config ) {
							var recids = [];
							var inspireColIdx = inspireColumnIndexes[0];

							dt.rows({ search: 'applied' }).every(function () {
								var data = this.data();
								// Ensure the data at inspireColIdx is actually present before pushing
								if (data[inspireColIdx]) {
								    recids.push(data[inspireColIdx]);
								}
							});

							if (recids.length === 0) {
								alert('No filtered rows to generate an Inspire API URL.');
								return;
							}

							var queryString = recids.map(recid => `recid:${recid}`).join(' OR ');
							var encodedQueryString = encodeURIComponent(queryString);

							var inspireApiUrl = `https://inspirehep.net/api/literature/?q=${encodedQueryString}&format=cv`;

							$.ajax({
								url: inspireApiUrl,
								method: 'GET',
								success: function(responseHtml) {
									var tempDiv = $('<div>').html(responseHtml);
									var processedHtml = '';
									var currentEntryDiv = null;

									tempDiv.contents().each(function(index, element) {
										var $element = $(element);
										// Check if it's a paragraph containing a bold link to an inspirehep literature entry
										if ($element.is('p') && $element.find('b a[href*="inspirehep.net/literature/"]').length) {

											if (currentEntryDiv) {
												processedHtml += currentEntryDiv.prop('outerHTML'); // Append previous entry
											}

											var href = $element.find('a').attr('href');
											var match = href ? href.match(/literature\/(\d+)$/) : null;
											var recid = (match && match[1]) ? match[1] : 'unknown';

											currentEntryDiv = $('<div>').attr('id', 'bib-recid-' + recid);
											currentEntryDiv.append($element.clone()); // Start new entry with this paragraph

										} else if (currentEntryDiv) {
											// Append subsequent elements to the current entry
											currentEntryDiv.append($element.clone());

										}
									});

									if (currentEntryDiv) {
										processedHtml += currentEntryDiv.prop('outerHTML'); // Append the last entry
									}

									$('#inspireApiContent').html(processedHtml);

									// Update table cells with links to generated bibliography
									dt.rows({ search: 'applied' }).every(function () {
										var rowNode = this.node(); // Get the HTML row element
										var rowData = this.data(); // Get the DataTables row data
										var currentRecid = rowData[inspireColIdx];
										var cell = $(rowNode).find('td').eq(inspireColIdx); // Find the cell

										if (currentRecid && $('#bib-recid-' + currentRecid).length) {
											cell.html(`<a href="#bib-recid-${currentRecid}">${currentRecid}</a>`);
										} else {
											cell.html(currentRecid); // Keep original if no match
										}
									});

								},
								error: function(jqXHR, textStatus, errorThrown) {
									console.error('Error fetching Inspire API content:', textStatus, errorThrown, jqXHR);
									$('#inspireApiContent').html('<p style="color: red;">Failed to load content. Please check the console for errors. Status: ' + textStatus + '</p>');
								}
							});
						}
					}
				]
			},
			bottomStart: 'info',
			bottomEnd: 'paging'
		},

		"columnDefs": [
			{	//Rendering for number columns
				"targets": numberColumnIndexes,
				"type": "num", // Essential for numerical sorting
				"render": function (data, type, row, meta) {
					let numericData = parseFloat(data);

					if (isNaN(numericData)) {
						return data; // Return original if not a number
					}

					// Apply Unit Conversion for Display and handle export/sort
					const colIdx = meta.col;
					if (numberColumnIndexes.includes(colIdx) && unitConversions[colIdx]) {
						// For display, get the currently selected unit and apply its factor
						if (type === 'display') {
							const currentUnitKey = getCurrentUnit(colIdx);
							const unitInfo = unitConversions[colIdx].units[currentUnitKey];
                            // Assuming 'numericData' (from your CSV) is already in the 'base unit' (factor: 1)
                            // If your CSV data is in 'default' unit and its factor is not 1,
                            // you'd first convert to the implicit base unit (value / default_factor),
                            // then convert to target unit ( * target_factor).
                            // But typically, you set the CSV's implicit unit to be the 'factor: 1' unit.
							const convertedValue = numericData * unitInfo.factor;
							return displayLatexNumber(convertedValue, 2, unitInfo.display);
						} else if (type === 'export' || type === 'sort') {
							 // Always export/sort the original numeric data in its base unit from CSV
							 return numericData.toExponential(2); // Provide scientific notation for export/sort
						}
					}

					// Fallback for types not handled by unit conversion, or non-number columns
					if (type === 'display') {
						 return displayLatexNumber(numericData, 2); // Original behavior without unit
					} else if (type === 'export') {
						return numericData.toExponential(2);
					}

					return data; // Default behavior
				}
			}
		],

		// To update LaTeX number rendering
		"drawCallback": function( settings ) {
			if (typeof MathJax !== 'undefined' && typeof MathJax.typesetPromise !== 'undefined') {
				// Only typeset if there are new math elements or potentially changed ones.
				// DataTables redraws entire cells, so MathJax needs to re-process those.
				MathJax.typesetPromise();
			}
		},

		initComplete: function () {

			var api = this.api();
			var thead = $(api.table().header());
			var filterRow = $('<tr>').appendTo(thead);

			api.columns().every(function (colIdx) {
				var column = this;
				var headerText = $(column.header()).text();
				var filterCell = $('<th>').appendTo(filterRow);

				if (filterColumnIndexes.includes(colIdx)) {
					// Existing Text Filter Dropdown
					var select = $('<select><option value="">All ' + headerText + '</option></select>')
						.appendTo(filterCell)
						.on('change', function () {
							var val = $(this).val();
							column
								.search(val ? '^' + val.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '$' : '', true, false)
								.draw();
						});
					column
						.data()
						.unique()
						.sort()
						.each(function (d, j) {
							select.append(
								'<option value="' + d + '">' + d + '</option>'
							);
						});
				} else if (numberColumnIndexes.includes(colIdx) && unitConversions[colIdx]) {
					// --- NEW: Unit Conversion Dropdown ---
					var unitSelect = $(`<select id="unit-select-${colIdx}"></select>`)
						.appendTo(filterCell)
						.on('change', function () {
							// DataTables 2.0+ way to trigger re-rendering:
							// Simply redraw the table. The render function for affected cells will be re-evaluated.
							api.draw(); // CORRECTED LINE
						});

					var units = unitConversions[colIdx].units;
					var defaultUnit = unitConversions[colIdx].default;

					// Populate dropdown with units for this column
					for (const unitKey in units) {
						if (units.hasOwnProperty(unitKey)) { // Best practice to check property
							unitSelect.append(
								`<option value="${unitKey}" ${unitKey === defaultUnit ? 'selected' : ''}>${units[unitKey].display}</option>`
							);
						}
					}
					// --- END NEW ---
				} else {
					filterCell.html('&nbsp;');
				}
			});
		}

	});

});

$(document).on('click', 'a[href^="#bib-recid-"]', function (e) {
	e.preventDefault();

	var targetId = this.getAttribute('href');
	var $target = $(targetId);

	if ($target.length) {

		$('.bib-highlight').removeClass('bib-highlight'); // Remove highlight from any previously highlighted entry

		$('html, body').animate({
			scrollTop: $target.offset().top - 50 // adjust offset if needed to account for fixed headers etc.
		}, 300, function () {
			$target.addClass('bib-highlight'); // Add highlight after scrolling
			setTimeout(() => {
				$target.removeClass('bib-highlight'); // Remove highlight after a delay
			}, 1500);
		});
	}
});
</script>
